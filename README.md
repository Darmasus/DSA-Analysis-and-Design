<b>CS 300 Portfolio Reflection</b>

Course: CS 300 – Data Structures and Algorithms<br>

Projects Included:<br>

Project One: Runtime and Memory Analysis of Data Structures

Project Two: Course Planner – Sorting and Displaying Courses in Alphanumeric Order<br>

<b>Reflection</b>

<b>What was the problem you were solving in the projects for this course?</b><br>
The goal was to analyze and implement efficient data structures to manage and organize information. In Project One, I compared the runtime and memory performance of different structures such as vectors, hash tables, and binary search trees. In Project Two, I applied these concepts to build a program that loads, sorts, and prints a list of courses in alphanumeric order, simulating a course advising system.

<b>How did you approach the problem? Consider why data structures are important to understand.</b><br>
I began by evaluating how different data structures handle storage, search, and retrieval operations. Understanding data structures is essential because they directly influence the efficiency and scalability of a program. For the final project, I selected a structure that balanced simplicity and speed while ensuring that the program could handle future data expansion without sacrificing performance.

<b>How did you overcome any roadblocks you encountered while going through the activities or project?</b><br>
One of the biggest challenges was debugging pointer and memory issues when working with dynamic data. I overcame these problems by using systematic testing and isolating each operation within the structure to verify correctness. Careful documentation and iterative testing helped prevent logic errors and improved overall reliability.

<b>How has your work on this project expanded your approach to designing software and developing programs?</b><br>
This project taught me to evaluate design choices not only by functionality but also by time and space efficiency. I learned to make data-driven design decisions supported by runtime analysis rather than intuition. It also reinforced the importance of abstraction and modular design, which simplifies debugging and future updates.

<b>How has your work on this project evolved the way you write programs that are maintainable, readable, and adaptable?</b><br>
I now prioritize writing clean, modular code with clear naming conventions and comments that explain purpose rather than implementation details. I also structure programs in a way that new data structures or algorithms can be integrated without breaking existing functionality. This approach ensures long-term maintainability and makes collaboration easier for future development teams.
